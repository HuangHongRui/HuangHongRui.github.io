<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Rui&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="锐锐君的个人技术博客,Web,前端">
<meta property="og:type" content="website">
<meta property="og:title" content="Rui&#39;s Blog">
<meta property="og:url" content="http://blog.luckyman.xyz/page/3/index.html">
<meta property="og:site_name" content="Rui&#39;s Blog">
<meta property="og:description" content="锐锐君的个人技术博客,Web,前端">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Rui&#39;s Blog">
<meta name="twitter:description" content="锐锐君的个人技术博客,Web,前端">
  
    <link rel="alternate" href="/atom.xml" title="Rui&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="https://raw.githubusercontent.com/HuangHongRui/Website_Page/master/src/img/hzw/39.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/plugin/bganimation/bg.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <div class="widget-wrap mobile-header">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://huanghongrui.github.io/css/images/lufei.jpg">
    <h2 class="author">Rui.</h2>
    <h3 class="description">锐锐君的个人技术博客,Web,前端</h3>
    <div class="count-box">
      <a href="/archives"><div><strong>35</strong><br>文章</div></a>
      <a href="/categories"><div><strong>14</strong><br>分类</div></a>
      <a href="/tags"><div><strong>35</strong><br>标签</div></a>
    </div>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

        <section id="main">
  
    <article id="post-单页面应用的优缺点" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/21/单页面应用的优缺点/" class="article-date">
  <time class="post-time" datetime="2017-08-21T06:29:03.000Z" itemprop="datePublished">
    <span class="post-month">8月</span><br/>
    <span class="post-day">21</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/21/单页面应用的优缺点/">单页面应用的优缺点</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/Web前端知识/">Web前端知识</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>优点<ul>
<li>用户体验好，加载速度快，内容的改变不需要重新加载整个页面。</li>
<li>减轻服务器压力。</li>
<li>因没有页面切换，所以没有白屏阻塞。</li>
</ul>
</li>
<li>缺点<ul>
<li>不利于SEO</li>
<li>初次加载耗时增多。</li>
<li>导航不可用</li>
<li>容易CSS命名冲突</li>
<li>页面复杂多提高，复杂逻辑难度提高</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.luckyman.xyz/2017/08/21/单页面应用的优缺点/" data-id="cjd9qc64v001j9b9zb6a9kvv1" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/单页面一个用/">单页面一个用</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-React-LifeCycle" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/20/React-LifeCycle/" class="article-date">
  <time class="post-time" datetime="2017-08-20T08:03:15.000Z" itemprop="datePublished">
    <span class="post-month">8月</span><br/>
    <span class="post-day">20</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/20/React-LifeCycle/">理解 React 生命周期</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/新知识/">新知识</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>React「just the UI」，相比 Angular、Ember 等完整的解决方案，上手相对容易。不过，React 生命周期还是会让新手迷惑，而掌握每个生命周期方法扮演的角色和执行时间又是至关重要的：</p>
<ul>
<li>什么时候进行事件绑定、数据请求、解除绑定等操作？</li>
<li>如何减少不必要的重渲染，提高性能？尽管 React 已经通过特定的算法优化渲染，但折中的处理方式仍会触发一些不必要的渲染。</li>
</ul>
<p>React 组件的生命周期有三个主要场景：</p>
<ul>
<li>装载（Mounting）：组件被插入到 DOM 中；</li>
<li>更新（Updating）：组件重新渲染以更新 DOM；</li>
<li>卸载（Unmounting）：组件从 DOM 中移除。</li>
</ul>
<p>不同的场景会调用不同的生命周期方法，包含 <code>will</code> 的方法在某个时间节点<strong>之前</strong>执行，包含 <code>did</code> 方法在某个时间节点<strong>之后</strong>执行。</p>
<h2 id="初始渲染（装载）"><a href="#初始渲染（装载）" class="headerlink" title="初始渲染（装载）"></a>初始渲染（装载）</h2><p><img src="http://blog.luckyman.xyz/box/Pic/initialMount.svg" alt=""></p>
<h2 id="getDefaultProps"><a href="#getDefaultProps" class="headerlink" title="getDefaultProps"></a>getDefaultProps</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">object getDefaultProps()</div></pre></td></tr></table></figure>
<p>该方法在<strong>组件创建时（createClass）执行一次并缓存</strong>返回值。如果组件使用时未设置属性，就从缓存中读取默认属性。<strong>注意</strong>：getDefaultProps() 返回的缓存数据会在所有实例间共享。</p>
<p><em>注意：<br>getDefaultProps 在任何实例创建之前执行，不在装载阶段执行，放在这里只是为了方便理解 React 组件初始化流程。</em></p>
<h2 id="getInitialState"><a href="#getInitialState" class="headerlink" title="getInitialState"></a>getInitialState</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">object getInitialState()</div></pre></td></tr></table></figure>
<p>组件装载之前执行一次，返回值用作 this.state 的初始值。</p>
<h2 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount"></a>componentWillMount</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void componentWillMount()</div></pre></td></tr></table></figure>
<p>初始渲染之前执行一次，前后端都有。如果在该方法中调用 setState，render() 将接收到更新后的数据，并且只会执行一次（即使状态已经改变）。</p>
<h2 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void componentDidMount()</div></pre></td></tr></table></figure>
<p>初始渲染完成后立即执行一次，只在客户端执行（服务器端没有）。</p>
<p>子组件的 <code>componentDidMount()</code> 方法先于父组件之前执行，此时可以操作子组件的任何引用（如操作子组件 DOM）。</p>
<p>在此方法中可进行：</p>
<ul>
<li>与其他 JavaScript 框架集成，如初始化 jQuery 插件；</li>
<li>使用 setTimeout/setInterval 设置定时器；</li>
<li>通过 Ajax/Fetch 获取数据；</li>
<li>绑定 DOM 事件；</li>
<li>……</li>
</ul>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>更新会在 React 组件初始渲染之后、卸载之前多次发生，属性、状态改变都会触发更新。</p>
<p>属性改变触发的更新流程：<br><img src="http://blog.luckyman.xyz/box/Pic/propsChange.svg" alt=""><br>状态改变触发的更新流程：<br><img src="http://blog.luckyman.xyz/box/Pic/stateChange.svg" alt=""></p>
<p>componentWillReceiveProps<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void componentWillReceiveProps(</div><div class="line">  object nextProps, object nextContext</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>组件即将接收新属性之前执行，初始渲染不执行。</p>
<p>该方法用于比较当前属性（<code>this.props</code>）和新属性（<code>nextProps</code>），以便决定是否通过 <code>this.setState()</code> 进行状态转换。此方法中调用 <code>this.setState()</code> 不会触发额外的渲染。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">componentWillReceiveProps: function(nextProps) &#123;</div><div class="line">  this.setState(&#123;</div><div class="line">    likesIncreasing: nextProps.likeCount &gt; this.props.likeCount</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><em>注意：<br>一个常犯的错误是<strong>编写此方法内的代码时，假定属性已经改变。</strong>也就是说，即使属性没有改变，React 仍会在后续更新时执行此方法，所以在编写相关逻辑时，应该先判断属性是否发生改变。</em></p>
<h2 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">boolean shouldComponentUpdate(</div><div class="line">  object nextProps, object nextState, object nextContext</div><div class="line">)</div></pre></td></tr></table></figure>
<p>组件接收到新属性或状态时执行，初始渲染及调用 <code>forceUpdate</code> 时不执行。</p>
<p>通过比较 <code>this.props</code> 与 <code>nextProps</code> 及 <code>this.state</code> 与 <code>nextState</code>，如果确定新属性、状态无需更新组件，则可以返回 <code>false</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">shouldComponentUpdate: function(nextProps, nextState) &#123;</div><div class="line">  return nextProps.id !== this.props.id;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果 <code>shouldComponentUpdate</code> 返回 <code>false</code>，此次更新的将跳过 render()，此外，<code>componentWillUpdate</code> 和 <code>componentDidUpdate</code> 也不会执行。</p>
<p><code>shouldComponentUpdate</code> 默认始终返回 <code>true</code>，以保证组件渲染与状态同步。</p>
<p>如果遇到性能瓶颈，尤其是有成百上千组件时，可以考虑使用 <code>shouldComponentUpdate</code> 优化应用。</p>
<h2 id="componentWillUpdate"><a href="#componentWillUpdate" class="headerlink" title="componentWillUpdate"></a>componentWillUpdate</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void componentWillUpdate(</div><div class="line">  object nextProps, object nextState, object nextContext</div><div class="line">)</div></pre></td></tr></table></figure>
<p>组件接收到新属性或状态即将重新渲染之前执行，初始渲染不执行。</p>
<p><em>注意：<br><strong>不能</strong>在此方法里使用 this.setState()。如果需要更新状态以响应属性变化，使用 componentWillReceiveProps 替代之。</em></p>
<h2 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void componentDidUpdate(</div><div class="line">  object prevProps, object prevState, object prevContext</div><div class="line">)</div></pre></td></tr></table></figure>
<p>组件更新后立即执行，初始渲染不执行。可用作操作发生变化 DOM 的时机。</p>
<h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p><img src="http://blog.luckyman.xyz/box/Pic/unmount.svg" alt=""></p>
<h2 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void componentWillUnmount()</div></pre></td></tr></table></figure>
<p>组件即将从 DOM 中卸载之前执行，可在此进行定时器清除、事件解绑等清理工作。</p>
<p>参考链接:<br><a href="https://facebook.github.io/react/docs/working-with-the-browser.html#component-lifecycle" target="_blank" rel="external">React Docs: Working With the Browser - Component Lifecycle</a><br><a href="https://facebook.github.io/react/docs/component-specs.html" target="_blank" rel="external">React Docs: Component Specs and Lifecycle</a><br><a href="https://facebook.github.io/react/docs/advanced-performance.html" target="_blank" rel="external">React Docs: Advanced Performance</a><br><a href="http://javascript.tutorialhorizon.com/2014/09/13/execution-sequence-of-a-react-components-lifecycle-methods/" target="_blank" rel="external">Execution sequence of a React component’s lifecycle methods</a><br><a href="https://csspod.com/understanding-reactjs-lifecycle-methods/" target="_blank" rel="external">文章原处</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.luckyman.xyz/2017/08/20/React-LifeCycle/" data-id="cjd9qc64f000s9b9zs8buftz6" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/">React</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-初识TypeScript-2" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/19/初识TypeScript-2/" class="article-date">
  <time class="post-time" datetime="2017-08-19T08:48:44.000Z" itemprop="datePublished">
    <span class="post-month">8月</span><br/>
    <span class="post-day">19</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/19/初识TypeScript-2/">初识TypeScript_2</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/新知识/">新知识</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h2><p>JS 的类型分为两种：</p>
<ul>
<li>原始数据类型（Primitive data types）<strong>包括：布尔值、数值、字符串、null、undefined Symbol。</strong></li>
<li>对象类型（Object types）。</li>
</ul>
<p>五种原始数据类型在 TypeScript 中的应用。</p>
<h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>布尔值是最基础的数据类型，在 TypeScript 中，使用 boolean 定义布尔值类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let isDone: boolean = false;</div></pre></td></tr></table></figure></p>
<p>注意，使用构造函数 Boolean 创造的对象不是布尔值：<br><code>let createdByNewBoolean: boolean = new Boolean(1);</code><br>报错: // index.ts(1,5): error TS2322: Type ‘Boolean’ is not assignable to type ‘boolean’.<br>      // 后面约定，未强调编译错误的代码片段，默认为编译通过</p>
<h3 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h3><p>使用 number 定义数值类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> let decLiteral: number = 6;</div><div class="line">let hexLiteral: number = 0xf00d;</div><div class="line">let notANumber: number = NaN;</div><div class="line">let infinityNumber: number = Infinity;</div></pre></td></tr></table></figure></p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>使用 string 定义字符串类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let myName: string = &apos;Xcat Liu&apos;;</div><div class="line">// 模板字符串</div><div class="line">let sentence: string = `Hello, my name is $&#123;myName&#125;. I&apos;ll be $&#123;myAge + 1&#125; years old next month.`;</div><div class="line">// 编译结果：模板字符串</div><div class="line">var sentence = &quot;Hello, my name is &quot; + myName + &quot;.\nI&apos;ll be &quot; + (myAge + 1) + &quot; years old next month.&quot;;</div></pre></td></tr></table></figure></p>
<h3 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h3><p>JS 没有空值（Void）的概念，在 TypeScirpt 中，可以用 void 表示没有任何返回值的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function alertName(): void &#123;</div><div class="line">  alert(&apos;My name is Rui&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let unusable: void = undefined;</div></pre></td></tr></table></figure></p>
<h3 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h3><p>在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let u: undefined = undefined;</div><div class="line">let n: null = null;</div></pre></td></tr></table></figure></p>
<p><strong>undefined 类型的变量只能被赋值为 undefined，null 类型的变量只能被赋值为 null。</strong></p>
<p>与 void 的 <strong>区别</strong> 是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 不报错： let num: number = undefined;</div><div class="line">// 不报错： let u: undefined; let num: number = u;</div></pre></td></tr></table></figure></p>
<p>void 类型的变量不能赋值给 number 类型的变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let u: void; let num: number = u;</div><div class="line">报错：// index.ts(2,5): error TS2322: Type &apos;void&apos; is not assignable to type &apos;number&apos;.</div></pre></td></tr></table></figure></p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>TypeScript像JS一样可以操作数组元素。 有两种方式可以定义数组。<br>第一种，可以在元素类型后面接上 []，表示由此类型元素组成的一个数组：<br><code>let list: number[] = [1, 2, 3];</code><br>第二种方式是使用数组泛型，Array&lt;元素类型&gt;：<br><code>let list: Array&lt;string&gt; = [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;];</code></p>
<h3 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 Tuple"></a>元组 Tuple</h3><p>元组类型允许表示一个<strong>已知元素数量和类型</strong>的数组，各元素的类型不必相同。 (比如，你可以定义一对值分别为 string和number类型的元组。)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let x: [string, number];</div><div class="line">x = [&apos;hello&apos;, 10]; // 正确</div><div class="line">x = [10, &apos;hello&apos;]; // Error</div></pre></td></tr></table></figure></p>
<p>当访问一个已知索引的元素，会得到正确的类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">console.log(x[0].substr(1)); // OK</div><div class="line">console.log(x[1].substr(1)); // Error, &apos;number&apos; does not have &apos;substr&apos;</div></pre></td></tr></table></figure></p>
<p>当访问一个越界的元素，会使用联合类型替代：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">x[3] = &apos;world&apos;; // OK, 字符串可以赋值给(string | number)类型</div><div class="line">console.log(x[5].toString()); // OK, &apos;string&apos; 和 &apos;number&apos; 都有 toString</div><div class="line">x[6] = true; // Error, 布尔不是(string | number)类型</div></pre></td></tr></table></figure></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><code>enum</code>类型是对JS 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">enum Color &#123;Red, Green, Blue&#125;</div><div class="line">let c: Color = Color.Green;</div></pre></td></tr></table></figure></p>
<p>默认情况下，从0开始为元素编号。<br>也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1开始编号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">enum Color &#123;Red = 1, Green, Blue&#125;</div><div class="line">let c: Color = Color.Green;</div></pre></td></tr></table></figure></p>
<p>或者，全部都采用手动赋值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">enum Color &#123;Red = 1, Green = 2, Blue = 4&#125;</div><div class="line">let c: Color = Color.Green;</div></pre></td></tr></table></figure></p>
<p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">enum Color &#123;Red = 1, Green, Blue&#125;</div><div class="line">let colorName: string = Color[2];</div></pre></td></tr></table></figure></p>
<h3 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h3><p>有时，会想要为那些在编程阶段还不清楚类型的变量指定一个类型。<br>这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。<br>这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。<br>那么我们可以使用 <code>any类型</code>来标记这些变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let notSure: any = 4;</div><div class="line">notSure = &quot;maybe a string instead&quot;;</div><div class="line">notSure = false;</div></pre></td></tr></table></figure></p>
<p>在对现有代码进行改写的时候，any类型是十分有用的， 它允许你在编译时可选择地包含或移除类型检查。<br>当你只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let list: any[] = [1, true, &quot;free&quot;];</div><div class="line">list[1] = 100;</div></pre></td></tr></table></figure></p>
<h3 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h3><p><code>never类型</code>表示的是那些永不存在的值的类型。<br>例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型；<br>变量也可能是 never类型，当它们被永不为真的类型保护所约束时。</p>
<p>never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never。</p>
<p>下面是一些返回never类型的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 返回never的函数必须存在无法达到的终点</div><div class="line">function error(message: string): never &#123;</div><div class="line">    throw new Error(message);</div><div class="line">&#125;</div><div class="line">// 推断的返回值类型为never</div><div class="line">function fail() &#123;</div><div class="line">    return error(&quot;Something failed&quot;);</div><div class="line">&#125;</div><div class="line">// 返回never的函数必须存在无法达到的终点</div><div class="line">function infiniteLoop(): never &#123;</div><div class="line">    while (true) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。<br>通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p>
<p>通过类型断言这种方式可以告诉编译器，<strong>“相信我，我知道自己在干什么”</strong>。<br>类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。<br>它没有运行时的影响，只是在编译阶段起作用。<br>TypeScript会假设你，程序员，已经进行了必须的检查。</p>
<p>类型断言有两种形式:</p>
<ul>
<li><p>其一是“尖括号”语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let someValue: any = &quot;this is a string&quot;;</div><div class="line">let strLength: number = (&lt;string&gt;someValue).length;</div></pre></td></tr></table></figure>
</li>
<li><p>另一个为as语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let someValue: any = &quot;this is a string&quot;;</div><div class="line">let strLength: number = (someValue as string).length;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>两种形式是等价的。至于使用哪个大多数情况下是凭个人喜好；然而，当你<strong>在TypeScript里使用JSX时，只有 as语法 断言是被允许的。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.luckyman.xyz/2017/08/19/初识TypeScript-2/" data-id="cjd9qc64q001a9b9z84q40hgl" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ScriptType/">ScriptType</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-初识TypeScript_1" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/17/初识TypeScript_1/" class="article-date">
  <time class="post-time" datetime="2017-08-17T05:56:31.000Z" itemprop="datePublished">
    <span class="post-month">8月</span><br/>
    <span class="post-day">17</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/17/初识TypeScript_1/">初识TypeScript_1</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/新知识/">新知识</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://www.typescriptlang.org/" target="_blank" rel="external">TypeScript官网-当前2.5版本</a></p>
<p>TypeScript是一种由微软开发的自由和开源的编程语言。<br>它是JavaScript的一个严格超集，并添加了可选的静态类型和基于类的面向对象编程。</p>
<p><strong>TypeScript设计目标：</strong>是开发大型应用，然后转译成JavaScript。由于TypeScript是JavaScript的严格超集，任何现有的JavaScript程序都是合法的TypeScript程序。</p>
<p>安装： <code>npm i -g typescript</code></p>
<p>根据官网提供的<strong>第一个TypeScript例子</strong>，创建一个 xxx.ts 文件，Code如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function greeter(person) &#123;</div><div class="line">    return &quot;Hello, &quot; + person;</div><div class="line">&#125;</div><div class="line">var user = &quot;Rui&quot;;</div><div class="line">document.body.innerHTML = greeter(user);</div></pre></td></tr></table></figure></p>
<p>Then,在命令行里输入 <code>tsc xxx.ts</code> ，可生成一个js文件..（将ts转换为js）<br><strong>Ps:</strong> 使用TS开发快捷方便，最后转换为JS投入使用.</p>
<p><strong>第二个例子： 类型注解</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function greeter(person:string) &#123;  // &lt;&lt;=这里</div><div class="line">    return &quot;Hello, &quot; + person;</div><div class="line">&#125;</div><div class="line">var user = [0,1,2];</div><div class="line">document.body.innerHTML = greeter(user);</div></pre></td></tr></table></figure></p>
<p>参数里面 <code>:string</code> 表示传入的参数变量值必须是字符串类型..<br>例子中传入的是数组：so 会自然报错：<code>error TS2345: Argument of type &#39;number[]&#39; is not assignable to parameter of type &#39;string&#39;.</code>，虽说报错，但是还是会生成JS文件（可能不会按预期执行）.<br>通过<strong>类型注解</strong>提供在编译时启动类型检查的静态类型。这是可选的，而且可以忽略而使用JavaScript常规的动态类型。 (对于基本类型的批注是number、bool和string。而弱或动态类型的结构则是any类型。)</p>
<p><strong>第三个例子： 接口</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">interface Person &#123;  &lt;&lt;= 1.接口</div><div class="line">    firstName: string;</div><div class="line">    lastName: string;</div><div class="line">&#125;</div><div class="line">function greeter(person: Person) &#123;  &lt;&lt;= 2.类型注解</div><div class="line">    return &apos;Hello, &apos;+person.firstName + &apos; &apos;+ person.lastName; </div><div class="line">&#125;</div><div class="line">var user = &#123;firstName: Huang, lastName: Rui&#125;</div><div class="line">greeter(user)</div></pre></td></tr></table></figure></p>
<p>这里使用接口来描述一个拥有firstName和lastName字段的对象。<br>在TypeScript里，只在两个类型内部的结构兼容那么这两个类型就是兼容的。<br>这就允许我们在实现接口时候只要保证包含了接口要求的结构就可以，而不必明确地使用 implements语句。</p>
<p><strong>使用类来扩展最后一个例子： 类</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Student&#123;  &lt;&lt;= 类</div><div class="line">    fullName: string;</div><div class="line">    constructor(public firstName,public middleInitial, public lastName)&#123;</div><div class="line">        this.fullName = firstName + &quot; &quot; + middleInitial + &quot; &quot; + lastName;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">interface Person&#123;  &lt;&lt;= 接口</div><div class="line">    firstName: string;</div><div class="line">    lastName: string;</div><div class="line">&#125;</div><div class="line">function greeter(person: Person)&#123;  &lt;&lt;= 类型注解</div><div class="line">    return &quot;Hello, &quot; + person.firstName + &quot; &quot; + person.lastName;</div><div class="line">&#125;</div><div class="line">var user = new Student(&apos;Rui&apos;, &apos;L&apos;, &apos;User&apos;)  &lt;&lt;= 实例化</div><div class="line">document.body.innerHTML = greeter(user)</div></pre></td></tr></table></figure></p>
<p>TypeScript支持JavaScript中的新功能，例如支持基于类的面向对象编程。<br>创建一个Student具有构造函数和几个公共字段的类。<br><strong>注意:</strong></p>
<ol>
<li>类和接口可以在一起共用，让程序员决定抽象的正确级别。</li>
<li>在构造函数的参数上使用public等同于创建了同名的成员变量。<br>使用 <code>public XXX</code> 等同于 <code>this XXX = XXX</code> 实例将继承起变量。</li>
</ol>
<p>运行TS Web应用：与平常引入外部JS脚本一样。<br><code>&lt;script src=&quot;greeter.js&quot;&gt;&lt;/script&gt;</code></p>
<p>在Visual Studio里打开greeter.ts或者把代码复制到<a href="https://www.typescriptlang.org/play/index.html" target="_blank" rel="external">TypeScript playground</a>。 </p>
<ol>
<li>将鼠标悬停在标识符上查看它们的类型。 </li>
<li>将光标放在 greeter函数上，点击F12可以跟踪到它的定义。</li>
<li>你可以右键点击标识，使用重构功能来重命名。<br><strong>注意：</strong>在某些情况下它们的类型可以被自动地推断出来。 重新输入一下最后一行代码，看一下自动补全列表和参数列表，它们会根据DOM元素类型而变化。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.luckyman.xyz/2017/08/17/初识TypeScript_1/" data-id="cjd9qc64o00169b9z7yqjejyd" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ScriptType/">ScriptType</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-Git-Command" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/16/Git-Command/" class="article-date">
  <time class="post-time" datetime="2017-08-16T05:32:17.000Z" itemprop="datePublished">
    <span class="post-month">8月</span><br/>
    <span class="post-day">16</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/16/Git-Command/">Git Command</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/使用操作/">使用操作</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Remember-Me"><a href="#Remember-Me" class="headerlink" title="Remember Me"></a>Remember Me</h2><p><img src="https://user-images.githubusercontent.com/26321899/31490643-3e662274-af77-11e7-8b75-8b8cdd705fa5.jpg" alt="快速上手"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.luckyman.xyz/2017/08/16/Git-Command/" data-id="cjd9qc645000c9b9z7njt4xxi" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Git/">Git</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-获取URL" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/15/获取URL/" class="article-date">
  <time class="post-time" datetime="2017-08-15T02:54:26.000Z" itemprop="datePublished">
    <span class="post-month">8月</span><br/>
    <span class="post-day">15</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/15/获取URL/">获取URL</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/Code/">Code</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="获取-URL-键值"><a href="#获取-URL-键值" class="headerlink" title="获取 URL 键值"></a>获取 URL 键值</h2><p>获取Key-Value字符串<br>先拆再合。</p>
<p>API:<br>    <code>location.search</code> 获取以?开头的键值字符串.<br>    <code>split()</code> 指定 分隔号字符字符串 将一个String对象分割成字符串数组。<br>    <code>substr()</code> 返回一个字符串中从指定位置开始到指定字符数的字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function obtain()&#123;</div><div class="line">    let url = location.search,</div><div class="line">        obj = new Object()</div><div class="line">    if (url.indexOf(&apos;?&apos;) != -1)&#123;</div><div class="line">        let str = url.substr(1),</div><div class="line">            strs = str.split(&apos;&amp;&apos;) </div><div class="line">        for (let i = 0; i &lt; strs.length; i++)&#123;</div><div class="line">            fast = strs[i].split(&apos;=&apos;)</div><div class="line">            obj[fast[0]] = fast[1]</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return obj </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/location" target="_blank" rel="external">更多方法-MDN</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.luckyman.xyz/2017/08/15/获取URL/" data-id="cjd9qc65e002c9b9z4pgvr58f" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Code/">Code</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-TCP传输的三次握手四次挥手策略" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/14/TCP传输的三次握手四次挥手策略/" class="article-date">
  <time class="post-time" datetime="2017-08-14T14:52:38.000Z" itemprop="datePublished">
    <span class="post-month">8月</span><br/>
    <span class="post-day">14</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/14/TCP传输的三次握手四次挥手策略/">TCP传输的三次握手四次挥手策略</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/HTTP/">HTTP</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="TCP的三次握手和四次挥手"><a href="#TCP的三次握手和四次挥手" class="headerlink" title="TCP的三次握手和四次挥手"></a>TCP的三次握手和四次挥手</h2><table>
<thead>
<tr>
<th style="text-align:center">FLAGS字段的几个标识</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SYN</td>
<td style="text-align:left">建立连接</td>
</tr>
<tr>
<td style="text-align:center">FIN</td>
<td style="text-align:left">关闭连接</td>
</tr>
<tr>
<td style="text-align:center">ACK</td>
<td style="text-align:left">响应/确认</td>
</tr>
<tr>
<td style="text-align:center">PSH</td>
<td style="text-align:left">传输/传送</td>
</tr>
<tr>
<td style="text-align:center">RST</td>
<td style="text-align:left">重置</td>
</tr>
<tr>
<td style="text-align:center">UGR</td>
<td style="text-align:left">紧急</td>
</tr>
<tr>
<td style="text-align:center">sequence number</td>
<td style="text-align:left">顺序号码</td>
</tr>
<tr>
<td style="text-align:center">acknowledge number</td>
<td style="text-align:left">确认号码</td>
</tr>
</tbody>
</table>
<p><img src="http://blog.luckyman.xyz/css/box/2.png" alt=""> </p>
<h3 id="HTTP连接"><a href="#HTTP连接" class="headerlink" title="HTTP连接"></a>HTTP连接</h3><p>HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。<br>HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。</p>
<p>1）在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。<br>2）在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。</p>
<p>由于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常 的做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道 客户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。</p>
<h3 id="SOCKET原理"><a href="#SOCKET原理" class="headerlink" title="SOCKET原理"></a>SOCKET原理</h3><p>【源IP地址】、【目的IP地址】、【源端口号】、【目的端口号】的组合称为套接字。其用于标识客户端请求的服务器和服务。</p>
<p>套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：</p>
<ol>
<li>连接使用的协议</li>
<li>本地主机的IP地址</li>
<li>本地进程的协议端口</li>
<li>远地主机的IP地址</li>
<li>远地进程的协议端口</li>
</ol>
<p>应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。</p>
<h3 id="建立socket连接"><a href="#建立socket连接" class="headerlink" title="建立socket连接"></a>建立socket连接</h3><p>建立条件：至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。<br>套接字间的连接过程分为三个步骤：1. 服务器监听，2. 客户端请求，3. 连接确认。</p>
<p>1) 服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。</p>
<p>2) 客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。</p>
<p>3) 连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发 给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</p>
<h3 id="Socket连接与HTTP连接"><a href="#Socket连接与HTTP连接" class="headerlink" title="Socket连接与HTTP连接"></a>Socket连接与HTTP连接</h3><p>由于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网 络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。<br>而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。<br>很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数 据传送给客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求， 不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。TCP(Transmission Control Protocol)　传输控制协议</p>
<h3 id="报文段是什么？"><a href="#报文段是什么？" class="headerlink" title="报文段是什么？"></a>报文段是什么？</h3><p>报文段是指TCP/IP协议网络传输过程中，起着路由导航，查询各个网络路由网段,IP地址，交换协议等IP数据包。报文段充当整个TCP/CP协议数据包的导航路由功能。</p>
<h3 id="TCP是什么"><a href="#TCP是什么" class="headerlink" title="TCP是什么?"></a>TCP是什么?</h3><p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。全双工模式.</p>
<p>TCP是一个超级麻烦的协议，而它又是互联网的基础，也是每个程序员必备的基本功。首先来看看OSI的七层模型：</p>
<p><img src="http://blog.luckyman.xyz/css/box/3.jpg" alt="在 TCP / IP 协议中数据先由上往下将数据装包，然后由下往上拆包"><br>在装包的时候，每一层都会增加一些信息用于传输，这部分信息就叫报头，当上层的数据到达本层的时候，会将数据加上本层的报头打包在一起，继续往下传递．<br>在拆包的时候，每一层将本层需要的报头读取后，就将剩下的数据往上传．</p>
<p>数据从应用层发下来，会在每一层都会加上头部信息，进行封装，然后再发送到数据接收端。这个基本的流程你需要知道，就是每个数据都会经过数据的封装和解封装的过程。 在OSI七层模型中，每一层的作用和对应的协议如下：</p>
<p><img src="http://blog.luckyman.xyz/css/box/4.gif" alt=""> </p>
<p><img src="http://blog.luckyman.xyz/css/box/4-1.jpg" alt="传统上来说 TCP/IP 被认为是一个四层协议"> </p>
<ol>
<li><p>网络接口层:<br>主要是指物理层次的一些接口,比如电缆等．</p>
</li>
<li><p>网络层:<br>提供独立于硬件的逻辑寻址,实现物理地址与逻辑地址的转换．<br>在 TCP / IP 协议族中，网络层协议包括 IP 协议（网际协议），ICMP 协议（ Internet 互联网控制报文协议），以及 IGMP 协议（ Internet 组管理协议）.</p>
</li>
<li><p>传输层:<br>为网络提供了流量控制,错误控制和确认服务.<br>在 TCP / IP 协议族中有两个互不相同的传输协议： TCP（传输控制协议）和 UDP（用户数据报协议）.</p>
</li>
<li><p>应用层:<br>为网络排错,文件传输,远程控制和 Internet 操作提供具体的应用程序<br>应用层做为 TCP/IP 协议的最高层级，对于我们移动开发来说，是接触最多的。</p>
</li>
</ol>
<h3 id="三次握手图"><a href="#三次握手图" class="headerlink" title="三次握手图"></a>三次握手图</h3><p><img src="http://blog.luckyman.xyz/css/box/5.jpg" alt=""> </p>
<p>第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；</p>
<p>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</p>
<p>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</p>
<p>完成了三次握手，客户端和服务器端就可以开始传送数据。</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。</p>
<p>第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</p>
<p>第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；</p>
<p>第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</p>
<p>第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</p>
<h3 id="什么是2MSL"><a href="#什么是2MSL" class="headerlink" title="什么是2MSL"></a>什么是2MSL</h3><p>MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为tcp报文（segment）是ip数据报（datagram）的数据部分，具体称谓请参见《数据在网络各层中的称呼》一文，而ip头中有一个TTL域，TTL是time to live的缩写，中文可以译为“生存时间”，这个生存时间是由源主机设置初始值但不是存的具体时间，而是存储了一个ip数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减1，当此值为0则数据报将被丢弃，同时发送ICMP报文通知源主机。RFC 793中规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等。</p>
<p>2MSL即两倍的MSL，TCP的TIME_WAIT状态也称为2MSL等待状态，当TCP的一端发起主动关闭，在发出最后一个ACK包后，即第3次握手完成后发送了第四次握手的ACK包后就进入了TIME_WAIT状态，必须在此状态上停留两倍的MSL时间，等待2MSL时间主要目的是怕最后一个ACK包对方没收到，那么对方在超时后将重发第三次握手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包。在TIME_WAIT状态时两端的端口不能使用，要等到2MSL时间结束才可继续使用。当连接处于2MSL等待阶段时任何迟到的报文段都将被丢弃。不过在实际应用中可以通过设置SO_REUSEADDR选项达到不必等待2MSL时间结束再使用此端口。</p>
<p>TTL与MSL是有关系的但不是简单的相等的关系，MSL要大于等于TTL。</p>
<h3 id="三次握手的原因"><a href="#三次握手的原因" class="headerlink" title="三次握手的原因"></a>三次握手的原因</h3><p>例子： </p>
<blockquote>
<p>“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的<strong>滞留</strong>了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”</p>
</blockquote>
<p>1 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。<br>2 为了解决“网络中存在延迟的重复分组”的问题。<br>3 防止了服务器端的一直等待而浪费资源。</p>
<h3 id="为什么要四次分手"><a href="#为什么要四次分手" class="headerlink" title="为什么要四次分手"></a>为什么要四次分手</h3><p><img src="http://blog.luckyman.xyz/css/box/6.jpg" alt=""><br>那四次分手又是为何呢？TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是<strong>全双工模式</strong>，<br>这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化。</p>
<ul>
<li>FIN_WAIT_1: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。（主动方）</li>
<li>FIN_WAIT_2：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK信息)，稍后再关闭连接。（主动方）</li>
<li>CLOSE_WAIT：这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。（被动方）</li>
<li>LAST_ACK: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。（被动方）</li>
<li>TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FINWAIT1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（主动方）</li>
<li>CLOSED: 表示连接中断。</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例:"></a>实例:</h3><p>IP 192.168.1.116.3337 &gt; 192.168.1.123.7788: S 3626544836:3626544836<br>IP 192.168.1.123.7788 &gt; 192.168.1.116.3337: S 1739326486:1739326486 ack 3626544837<br>IP 192.168.1.116.3337 &gt; 192.168.1.123.7788: ack 1739326487,ack 1</p>
<p>第一次握手：192.168.1.116发送位码syn＝1,随机产生seq number=3626544836的数据包到192.168.1.123,192.168.1.123由SYN=1知道192.168.1.116要求建立联机;</p>
<p>第二次握手：192.168.1.123收到请求后要确认联机信息，向192.168.1.116发送ack number=3626544837,syn=1,ack=1,随机产生seq=1739326486的包;</p>
<p>第三次握手：192.168.1.116收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，192.168.1.116会再发送ack number=1739326487,ack=1，192.168.1.123收到后确认seq=seq+1,ack=1则连接建立成功。</p>
<h3 id="搬运文章"><a href="#搬运文章" class="headerlink" title="搬运文章"></a>搬运文章</h3><p><a href="https://github.com/jawil/blog/issues/14" target="_blank" rel="external">通俗大白话来理解TCP协议的三次握手和四次分手</a><br><a href="http://blog.csdn.net/oney139/article/details/8103223" target="_blank" rel="external">TCP三次握手详解及释放连接过程</a><br><a href="http://www.cnblogs.com/yuilin/archive/2012/11/05/2755298.html#!comments" target="_blank" rel="external">首先简单介绍一下TCP三次握手</a><br><a href="https://www.zhihu.com/question/24853633" target="_blank" rel="external">TCP 为什么是三次握手，为什么不是两次或四次？</a><br><a href="https://juejin.im/post/58e36d35b123db15eb748856" target="_blank" rel="external">面试时，你被问到过 TCP/IP 协议吗?</a></p>
<p>最后推荐一个学习HTTP的github项目地址：<a href="https://github.com/woai30231/http" target="_blank" rel="external">我自己提炼的关于《HTTP权威指南》每章的知识点总结！</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.luckyman.xyz/2017/08/14/TCP传输的三次握手四次挥手策略/" data-id="cjd9qc64k00109b9zm55m430k" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-HTTP-Method" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/13/HTTP-Method/" class="article-date">
  <time class="post-time" datetime="2017-08-13T13:50:49.000Z" itemprop="datePublished">
    <span class="post-month">8月</span><br/>
    <span class="post-day">13</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/13/HTTP-Method/">常见 HTTP Method</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/HTTP/">HTTP</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>常见的六种 HTTP Method分別是 </p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>head</strong></td>
<td style="text-align:center">与get一样，但无响应体</td>
</tr>
<tr>
<td style="text-align:center"><strong>get</strong></td>
<td style="text-align:center">请求一个指定资源的表示形式. 常被用于获取数据.</td>
</tr>
<tr>
<td style="text-align:center"><strong>post</strong></td>
<td style="text-align:center">用于将实体提交到指定的资源，通常导致状态或服务器上的副作用的更改.</td>
</tr>
<tr>
<td style="text-align:center"><strong>delete</strong></td>
<td style="text-align:center">删除指定的资源。</td>
</tr>
<tr>
<td style="text-align:center"><strong>put</strong></td>
<td style="text-align:center">用请求有效载荷替换目标资源的所有当前表示。</td>
</tr>
<tr>
<td style="text-align:center"><strong>patch</strong></td>
<td style="text-align:center">用于对资源应用部分修改。</td>
</tr>
</tbody>
</table>
<p>不同的 Method 就是对同一件事情做不同的操作。<br>举个例子：<br>假设现在我們要点餐，</p>
<ol>
<li>需要先知道菜单是什么（get 获取），</li>
<li>會向服务员点餐（post 提交），</li>
<li>想要取消取消刚点的菜单（delete），</li>
<li>想要重新一次（put），</li>
<li>想要加点甜点和饮料（patch）。</li>
</ol>
<p>head是取得get的http header而不取得內容，性質上我們可以當作跟get一樣</p>
<p>head：和get一樣，只是head只會取的HTTP header的資料。<br>get：取得我們想要的資料。<br>post：新增一項資料。（如果存在會新增一個新的）<br>put：新增一項資料，如果存在就覆蓋過去。（還是只有一筆資料）。<br>patch：附加新的資料在已經存在的資料後面。（資料必須已經存在，patch會擴充這項資料）<br>delete：刪除資料。</p>
<p>参考转载：<br><a href="https://data-sci.info/2015/10/24/%E5%B8%B8%E8%A6%8B%E7%9A%84http-method%E7%9A%84%E4%B8%8D%E5%90%8C%E6%80%A7%E8%B3%AA%E5%88%86%E6%9E%90%EF%BC%9Agetpost%E5%92%8C%E5%85%B6%E4%BB%964%E7%A8%AEmethod%E7%9A%84%E5%B7%AE%E5%88%A5/" target="_blank" rel="external">常見的HTTP METHOD的不同性質分析：GET,POST和其他4種METHOD的差別</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.luckyman.xyz/2017/08/13/HTTP-Method/" data-id="cjd9qc647000g9b9zn9rntioo" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/">HTTP</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-收藏夹" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/12/收藏夹/" class="article-date">
  <time class="post-time" datetime="2017-08-12T11:33:30.000Z" itemprop="datePublished">
    <span class="post-month">8月</span><br/>
    <span class="post-day">12</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/12/收藏夹/">干货</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/收藏夹/">收藏夹</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p><a href="https://github.com/jawil/blog/issues/14" target="_blank" rel="external">通俗大白话来理解TCP协议的三次握手和四次分手</a></p>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS:"></a>CSS:</h2><p><a href="http://www.w3cplus.com/" target="_blank" rel="external">大漠的个人博客w3cplus</a></p>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript:"></a>JavaScript:</h2><p><a href="http://louiszhai.github.io/2017/03/12/promise/" target="_blank" rel="external">Promise使用手册</a><br><a href="http://liubin.org/promises-book/" target="_blank" rel="external">JavaScript Promise迷你书</a><br><a href="https://segmentfault.com/a/1190000004322487#articleHeader17" target="_blank" rel="external">你真的会使用XMLHttpRequest吗？</a><br><a href="https://segmentfault.com/a/1190000004556040" target="_blank" rel="external">聊一聊 cookie</a></p>
<h2 id="BlogPost："><a href="#BlogPost：" class="headerlink" title="BlogPost："></a>BlogPost：</h2><p><a href="http://louiszhai.github.io/2016/12/23/sort/" target="_blank" rel="external">JS中可能用得到的全部的排序算法</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.luckyman.xyz/2017/08/12/收藏夹/" data-id="cjd9qc65600219b9zabu62l30" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-常见布局" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/08/11/常见布局/" class="article-date">
  <time class="post-time" datetime="2017-08-11T08:48:21.000Z" itemprop="datePublished">
    <span class="post-month">8月</span><br/>
    <span class="post-day">11</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/08/11/常见布局/">常见布局</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/Web前端知识/">Web前端知识</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="常见布局"><a href="#常见布局" class="headerlink" title="常见布局"></a>常见布局</h2><p>将代码贴入显示效果更佳，便于理解。 <a href="https://codepen.io/" target="_blank" rel="external">Codepen</a> |  <a href="https://jsfiddle.net/" target="_blank" rel="external">Jsfiddle</a> | <a href="https://jsbin.com/?html,css,js,console,output" target="_blank" rel="external">JSBIN</a></p>
<ul>
<li>固定宽度</li>
<li>弹性布局</li>
<li><p>响应式布局</p>
<ul>
<li><p>一栏布局</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">HTML:</div><div class="line">&lt;div class=&quot;container&quot;&gt;</div><div class="line">  &lt;div class=&quot;header&quot;&gt;&lt;/div&gt;</div><div class="line">  &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</div><div class="line">  &lt;div class=&quot;footer&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">CSS:</div><div class="line">.container&#123;</div><div class="line">  max-width: 960px;</div><div class="line">  margin: 0 auto;</div><div class="line">&#125;</div><div class="line">.header&#123;</div><div class="line">  height: 60px;</div><div class="line">  background-color: #00C853;</div><div class="line">&#125;</div><div class="line">.content&#123;</div><div class="line">  height: 400px;</div><div class="line">  background-color: #E0E0E0;</div><div class="line">&#125;</div><div class="line">.footer&#123;</div><div class="line">  height: 50px;</div><div class="line">  background-color: #03A9F4;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>一栏布局（通栏）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">HTML:</div><div class="line">&lt;div class=&quot;container&quot;&gt;</div><div class="line">  &lt;div class=&quot;layout&quot; id=&quot;header&quot;&gt;&lt;/div&gt;</div><div class="line">  &lt;div class=&quot;layout&quot; id=&quot;content&quot;&gt;&lt;/div&gt;</div><div class="line">  &lt;div class=&quot;layout&quot; id=&quot;footer&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">CSS:</div><div class="line">.layout &#123;</div><div class="line">  min-width: 960px;</div><div class="line">  margin: 0 auto;</div><div class="line">&#125;</div><div class="line">#header &#123;</div><div class="line">  height: 60px;</div><div class="line">  background-color: #00C853;</div><div class="line">&#125;</div><div class="line">#content &#123;</div><div class="line">  height: 400px;</div><div class="line">  background-color: #E0E0E0;</div><div class="line">&#125;</div><div class="line">#footer &#123;</div><div class="line">  height: 50px;</div><div class="line">  background-color: #03A9F4;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>双栏布局<br>一列固定宽度，另外一列自适应宽度<code>float + margin</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">HTML:</div><div class="line">&lt;div class=&quot;container&quot;&gt;</div><div class="line">  &lt;div class=&quot;side&quot;&gt;&lt;/div&gt;</div><div class="line">  &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;div class=&quot;footer&quot;&gt;&lt;/div&gt;</div><div class="line">CSS:</div><div class="line">.container &#123;</div><div class="line">  overflow: hidden;</div><div class="line">&#125;</div><div class="line">.side &#123;</div><div class="line">  width: 200px;</div><div class="line">  height: 500px;</div><div class="line">  background-color: #00C853;</div><div class="line">  float: left;</div><div class="line">&#125;</div><div class="line">.main &#123;</div><div class="line">  margin-left: 210px;</div><div class="line">  height: 400px;</div><div class="line">  background: #03A9F4;</div><div class="line">&#125;</div><div class="line">.footer &#123;</div><div class="line">  height: 50px;</div><div class="line">  background-color: #FFCA28;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>三列布局<br>浮动方法：左右<code>float</code>，中间左右<code>margin</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">HTML:</div><div class="line">&lt;div class=&quot;container&quot;&gt;</div><div class="line">  &lt;div class=&quot;side&quot;&gt;&lt;/div&gt;</div><div class="line">  &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</div><div class="line">  &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;div class=&quot;footer&quot;&gt;&lt;/div&gt;</div><div class="line">CSS:</div><div class="line">.container &#123;</div><div class="line">  overflow: hidden;</div><div class="line">&#125;</div><div class="line">.side,</div><div class="line">.right &#123;</div><div class="line">  width: 200px;</div><div class="line">  height: 500px;</div><div class="line">  background-color: #00C853;</div><div class="line">  float: left;</div><div class="line">&#125;</div><div class="line">.main &#123;</div><div class="line">  margin-right: 210px;</div><div class="line">  margin-left: 210px;</div><div class="line">  height: 400px;</div><div class="line">  background: #03A9F4;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.right &#123;</div><div class="line">  float: right;  </div><div class="line">&#125;</div><div class="line"></div><div class="line">.footer &#123;</div><div class="line">  height: 50px;</div><div class="line">  background-color: #FFCA28;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>绝对定位方法： 左右<code>absolute</code>中间左右<code>margin</code>底部<code>margin-top</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">.container &#123;</div><div class="line">  width: 100%;</div><div class="line">&#125;</div><div class="line">.side,</div><div class="line">.right &#123;</div><div class="line">  width: 200px;</div><div class="line">  height: 500px;</div><div class="line">  background-color: #00C853;</div><div class="line">  position: absolute;</div><div class="line">&#125;</div><div class="line">.main &#123;</div><div class="line">  margin-right: 210px;</div><div class="line">  margin-left: 210px;</div><div class="line">  height: 400px;</div><div class="line">  background: #03A9F4;</div><div class="line">&#125;</div><div class="line">.side &#123;</div><div class="line">  left: 0;</div><div class="line">&#125;</div><div class="line">.right &#123;</div><div class="line">  right: 0;</div><div class="line">&#125;</div><div class="line">.footer &#123;</div><div class="line">  height: 50px;</div><div class="line">  background-color: #FFCA28;</div><div class="line">  margin-top: 120px;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><p>双飞翼布局<br>全部浮动，BFC，中间子main左右margin，left和right均margin-left到位置上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">HTML:</div><div class="line">&lt;div class=&quot;wrap&quot;&gt;</div><div class="line">  &lt;div class=&quot;main-content&quot;&gt;</div><div class="line">    &lt;div class=&quot;main&quot;&gt;main-content&lt;/div&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">  &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;</div><div class="line">  &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">CSS:</div><div class="line">.wrap &#123;</div><div class="line">  width: 100%;</div><div class="line">&#125;</div><div class="line">.wrap::after &#123;</div><div class="line">  display: block;</div><div class="line">  content: &apos;&apos;;</div><div class="line">  font-size: 0;</div><div class="line">  height: 0;</div><div class="line">  clear: both;</div><div class="line">  zoom: 1;</div><div class="line">&#125;</div><div class="line">.main-content &#123;</div><div class="line">  float: left;</div><div class="line">  width: 100%;</div><div class="line">&#125;</div><div class="line">.main &#123;</div><div class="line">  height: 100px;</div><div class="line">  background-color: green;</div><div class="line">  margin-left: 110px;</div><div class="line">  margin-right: 110px;</div><div class="line">  opacity: 0.5;</div><div class="line">&#125;</div><div class="line">.left &#123;</div><div class="line">  float: left;</div><div class="line">  width: 100px;</div><div class="line">  height: 100px;</div><div class="line">  background-color: orange;</div><div class="line">  margin-left: -100%;</div><div class="line">  z-index: 100;</div><div class="line">&#125;</div><div class="line">.right &#123;</div><div class="line">  float: left;</div><div class="line">  width: 100px;</div><div class="line">  height: 100px;</div><div class="line">  background-color: orange;</div><div class="line">  margin-left: -100px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>圣杯布局<br>要点：<br>是3列布局，两边固定宽度，中间自适应；<br>中间内容元素在dom元素次序种优先位置。<br>缺点：<br>自适应的最小宽度不能小于左边列的宽度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">HTML:</div><div class="line">&lt;div id=&quot;content&quot; class=&quot;clearfix&quot;&gt;</div><div class="line">    &lt;div class=&quot;main&quot;&gt;main&lt;/div&gt;</div><div class="line">    &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;</div><div class="line">    &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">CSS:</div><div class="line">#clearfix:after&#123;</div><div class="line">    content: &quot;&quot;;</div><div class="line">    clear: both;</div><div class="line">    display: block;</div><div class="line">&#125;</div><div class="line">#content&#123;</div><div class="line">    padding: 0 110px 0 110px;</div><div class="line">&#125;</div><div class="line">.main &#123;</div><div class="line">    width: 100%;</div><div class="line">    height: 100px;</div><div class="line">    background-color: green;</div><div class="line">&#125;</div><div class="line">.left &#123;</div><div class="line">    width: 100px;</div><div class="line">    height: 100px;</div><div class="line">    background-color: orange;</div><div class="line">    margin-left: -100%;</div><div class="line">    position: relative;</div><div class="line">    left: -110px;</div><div class="line">&#125;</div><div class="line">.right &#123;</div><div class="line">    width: 100px;</div><div class="line">    height: 100px;</div><div class="line">    background-color: orange;</div><div class="line">    margin-left: -100px;</div><div class="line">    position: relative;</div><div class="line">    right: -110px;</div><div class="line">&#125;</div><div class="line">.main,.left,.right&#123;</div><div class="line">    float: left;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>参考：</p>
<p><a href="https://alistapart.com/article/holygrail" target="_blank" rel="external">In Search of the Holy Grail</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.luckyman.xyz/2017/08/11/常见布局/" data-id="cjd9qc652001v9b9z8mreky5s" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/页面布局/">页面布局</a></li></ul>

    </footer>
  </div>
  
</article>




  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; pre</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">next &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <h1 class="blog-title">Rui&#39;s Blog</h1>
    <h2 class="blog-subtitle">不学则汰,无策则乱..</h2>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://huanghongrui.github.io/css/images/lufei.jpg">
    <h2 class="author">Rui.</h2>
    <h3 class="description">锐锐君的个人技术博客,Web,前端</h3>
    <div class="count-box">
      <a href="/archives"><div><strong>35</strong><br>文章</div></a>
      <a href="/categories"><div><strong>14</strong><br>分类</div></a>
      <a href="/tags"><div><strong>35</strong><br>标签</div></a>
    </div>



    <div class="social-link">
      
        <a class="hvr-bounce-in" href="http://github.com/HuangHongRui" target="_blank" title="Github">
          Github
        </a>
      
    </div>

    <div class="friend-link">
      <h2>友情链接</h2>
      
        <a class="hvr-bounce-in" href="http://blog.csdn.net/leonishuang" target="_blank" title="CSDN_Blog">
          CSDN_Blog
        </a>
      
        <a class="hvr-bounce-in" href="http://www.jianshu.com/u/4fe15f8f16d3" target="_blank" title="简书_Blog">
          简书_Blog
        </a>
      
        <a class="hvr-bounce-in" href="http://blog.liyu0906.cn/" target="_blank" title="Albert">
          Albert
        </a>
      
        <a class="hvr-bounce-in" href="https://spontaleo.github.io/" target="_blank" title="SpontaLeo">
          SpontaLeo
        </a>
      
        <a class="hvr-bounce-in" href="https://frankietang.github.io/" target="_blank" title="Frankie Tang">
          Frankie Tang
        </a>
      
    </div>
  </div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy;2017 - 2018 Rui.<br>
      由<a href="http://hexo.io/" target="_blank">Hexo</a>强力驱动 | 
      主题-<a href="https://github.com/ShanaMaid/hexo-theme-shana">Shana</a>
      
        |<script src="http://s11.cnzz.com/z_stat.php?id=269&web_id=269" language="JavaScript"></script>
      
    </div>
    
  </div>
</footer>
    </div>
    

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="//apps.bdimg.com/libs/wow/0.1.6/wow.min.js"></script>
<script>
new WOW().init();
</script>   


  <link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">
  <script src="/plugin/fancybox/jquery.fancybox.pack.js"></script>



  <link rel="stylesheet" href="/plugin/galmenu/GalMenu.css">
  <script src="/plugin/galmenu/GalMenu.js"></script>
  <div class="GalMenu GalDropDown">
      <div class="circle" id="gal">
        <div class="ring">
          
            <a href="/" title="" class="menuItem">首页</a>
          
            <a href="/tags" title="" class="menuItem">标签</a>
          
            <a href="/categories" title="" class="menuItem">分类</a>
          
            <a href="/archives" title="" class="menuItem">归档</a>
          
            <a href="/xxxxxxxxx" title="" class="menuItem">xxx</a>
          
            <a href="/xxxxxxx" title="" class="menuItem">xxxx</a>
          
        </div>
        
          <audio id="audio" src="#"></audio>
        
      </div> 
</div>
<div id="overlay" style="opacity: 1; cursor: pointer;"></div>
  <script type="text/javascript">var items = document.querySelectorAll('.menuItem');
    for (var i = 0,
    l = items.length; i < l; i++) {
      items[i].style.left = (50 - 35 * Math.cos( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%";
      items[i].style.top = (50 + 35 * Math.sin( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%"
    }</script>
<script type="text/javascript">
  $(document).ready(function() {
    $('body').GalMenu({
      'menu': 'GalDropDown'
    })
  });
</script>

  <section class="hidden-xs"> 
  <ul class="cb-slideshow"> 
    <li><span></span></li>
    <li><span></span></li>
    <li><span></span></li>
    <li><span></span></li>
    <li><span></span></li>
    <li><span></span></li>
  </ul>
</section>
<script src="/js/script.js"></script>



  </div>
</body>
</html>